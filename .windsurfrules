- **Use Python 3.11 as the target version**: Ensure all code is compatible with Python 3.11, as specified in the technical stack, to maintain consistency with the MCP Python SDK and deployment environment.
- **Adhere to MCP SDK conventions**: Structure the server implementation using the MCP Python SDK’s `Server` class, `call_tool`, and `list_tools` decorators, following the patterns in the provided SDK examples at https://github.com/modelcontextprotocol/python-sdk.
- **Implement tools with TextContent output**: Format all tool outputs (e.g., address objects, security zones, security policies) as `mcp.types.TextContent` objects with JSON-like string content, per the PRD’s functional requirements.
- **Use async/await for I/O operations**: Write all network calls (e.g., Palo Alto API requests via `httpx`) and MCP server operations using async/await to support asynchronous execution as required by the SDK and PRD.
- **Validate tool parameters explicitly**: Add input validation for `location` and `vsys` parameters in each tool, raising exceptions for missing or invalid values, to meet the security requirement of preventing injection attacks.
- **Organize code into specified modules**: Place the main server logic in `src/main.py`, Palo Alto API integration in `src/palo_alto_api.py`, and tool definitions in `src/tools.py`, matching the PRD’s directory structure.
- **Configure SSE transport as default**: Set up the server to use Server-Sent Events (SSE) transport via `/messages/` endpoint, as specified in the PRD, and ensure compatibility with Windsurf MCP client workflows.
- **Read sensitive data from environment variables**: Access Palo Alto API keys from environment variables or Kubernetes Secrets (via `os.environ`), avoiding hardcoding to comply with security requirements.
- **Add structured logging with request IDs**: Include logging in `src/main.py` with a unique request ID for each tool call, using a format like `{"request_id": "...", "message": "..."}`, to support monitoring requirements.
- **Follow Kubernetes deployment conventions**: Write Kubernetes manifests in `kubernetes/deployment.yaml` with 2 replicas, liveness/readiness probes, and a `mcp-paloalto` namespace, aligning with the PRD’s deployment specs.
- **Use `httpx` for Palo Alto API calls**: Implement all HTTPS requests to the Palo Alto NGFW XML API using the `httpx` library, ensuring async compatibility and proper error handling as per the PRD.
- **Document tool schemas in code**: Define each tool’s input schema (e.g., `{"type": "object", "required": ["location", "vsys"], ...}`) in the `list_tools` handler, matching the PRD’s tool definitions.
- **Avoid external frameworks beyond MCP SDK**: Do not introduce additional frameworks like FastAPI or Flask; rely solely on the MCP Python SDK and specified dependencies (`mcp`, `httpx`, `anyio`) to maintain project scope.
- **Test locally with MCP client**: Use the MCP client example from the SDK to test tools locally via SSE transport, ensuring compatibility with Windsurf’s expected workflow before deployment.
- **Keep Dockerfile minimal**: Write a lean `Dockerfile` that installs Python 3.11, copies only `src/` and `requirements.txt`, and runs `main.py`, optimizing for container deployment as per the PRD.
